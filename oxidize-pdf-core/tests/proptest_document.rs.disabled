//! Property-based tests for document operations
//!
//! Tests invariants and properties of Document manipulation operations
//! to ensure consistency and correctness across all inputs.

use oxidize_pdf::operations::PageRotation;
use oxidize_pdf::text::Font;
use oxidize_pdf::{Document, Page, PageSize, Result};
use proptest::prelude::*;
use tempfile::TempDir;

// Strategy for generating page sizes
fn page_size_strategy() -> impl Strategy<Value = PageSize> {
    prop_oneof![
        Just(PageSize::A4),
        Just(PageSize::Letter),
        Just(PageSize::Legal),
        Just(PageSize::A3),
        Just(PageSize::A5),
        // Custom sizes
        (100.0..2000.0f64, 100.0..2000.0f64).prop_map(|(w, h)| PageSize::Custom(w, h)),
    ]
}

// Strategy for generating valid page rotations
fn rotation_strategy() -> impl Strategy<Value = PageRotation> {
    prop_oneof![
        Just(PageRotation::None),
        Just(PageRotation::Rotate90),
        Just(PageRotation::Rotate180),
        Just(PageRotation::Rotate270),
    ]
}

// Strategy for generating metadata strings
fn metadata_string_strategy() -> impl Strategy<Value = String> {
    prop_oneof![
        // Normal ASCII strings
        "[a-zA-Z0-9 .-]{0,100}",
        // Empty string
        Just(String::new()),
        // Unicode strings
        "\\PC{0,50}",
        // Strings with special characters
        "[a-zA-Z0-9 !@#$%^&*()_+-=]{0,100}",
    ]
}

proptest! {
    #[test]
    fn test_document_page_count_consistency(num_pages in 0..100usize) {
        let mut doc = Document::new();

        // Add pages
        for _ in 0..num_pages {
            doc.add_page(Page::a4());
        }

        // Page count should match
        prop_assert_eq!(doc.pages.len(), num_pages);
    }

    #[test]
    fn test_document_metadata_preservation(
        title in metadata_string_strategy(),
        author in metadata_string_strategy(),
        subject in metadata_string_strategy(),
        keywords in metadata_string_strategy(),
    ) {
        let mut doc = Document::new();

        // Set metadata
        doc.set_title(&title);
        doc.set_author(&author);
        doc.set_subject(&subject);
        doc.set_keywords(&keywords);

        // Metadata should be preserved
        // (We can't directly access it, but we can verify it doesn't crash)
        prop_assert!(true);
    }

    #[test]
    fn test_page_rotation_values(rotation in rotation_strategy()) {
        let mut page = Page::a4();
        page.set_rotation(rotation);

        // Rotation should be one of the valid values
        match rotation {
            PageRotation::None => prop_assert!(true),
            PageRotation::Rotate90 => prop_assert!(true),
            PageRotation::Rotate180 => prop_assert!(true),
            PageRotation::Rotate270 => prop_assert!(true),
        }
    }

    #[test]
    fn test_page_size_dimensions(size in page_size_strategy()) {
        let page = Page::new(size);

        // All page sizes should have positive dimensions
        let (width, height) = match size {
            PageSize::A4 => (595.0, 842.0),
            PageSize::Letter => (612.0, 792.0),
            PageSize::Legal => (612.0, 1008.0),
            PageSize::A3 => (842.0, 1191.0),
            PageSize::A5 => (420.0, 595.0),
            PageSize::Custom(w, h) => (w, h),
        };

        prop_assert!(width > 0.0);
        prop_assert!(height > 0.0);
    }

    #[test]
    fn test_document_save_load_roundtrip(
        title in "[a-zA-Z0-9 ]{0,50}",
        num_pages in 1..10usize
    ) {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.pdf");

        // Create document
        let mut doc = Document::new();
        doc.set_title(&title);

        for i in 0..num_pages {
            let mut page = Page::a4();
            // Add some content
            let _ = page.text()
                .set_font(Font::Helvetica, 12.0)
                .at(100.0, 700.0)
                .write(&format!("Page {}", i + 1));
            doc.add_page(page);
        }

        // Save document
        match doc.save(&file_path) {
            Ok(_) => {
                // Verify file exists
                prop_assert!(file_path.exists());

                // Verify file is not empty
                let metadata = std::fs::metadata(&file_path).unwrap();
                prop_assert!(metadata.len() > 0);
            }
            Err(_) => {
                // Save might fail for valid reasons (disk full, permissions)
                prop_assert!(true);
            }
        }
    }

    #[test]
    fn test_compression_toggle(compress in any::<bool>()) {
        let mut doc = Document::new();
        doc.set_compress(compress);

        // Add a page with repetitive content (good for compression)
        let mut page = Page::a4();
        let repetitive_text = "AAAAAAAAAA ".repeat(100);
        let _ = page.text()
            .set_font(Font::Helvetica, 10.0)
            .at(50.0, 700.0)
            .write(&repetitive_text);
        doc.add_page(page);

        // Document should handle compression setting
        prop_assert!(true);
    }

    #[test]
    fn test_multiple_pages_independence(num_pages in 2..20usize) {
        let mut doc = Document::new();

        // Each page should be independent
        for i in 0..num_pages {
            let mut page = Page::a4();

            // Different content on each page
            let _ = page.text()
                .set_font(Font::Helvetica, 12.0)
                .at(100.0, 700.0)
                .write(&format!("This is page {}", i));

            // Different rotation on some pages
            if i % 2 == 0 {
                page.set_rotation(PageRotation::Rotate90);
            }

            doc.add_page(page);
        }

        // Document should have all pages
        prop_assert_eq!(doc.pages.len(), num_pages);
    }

    #[test]
    fn test_empty_document_valid() {
        let doc = Document::new();

        // Empty document (no pages) should be valid
        prop_assert_eq!(doc.pages.len(), 0);

        // Should be able to save empty document
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("empty.pdf");

        match doc.save(&file_path) {
            Ok(_) => prop_assert!(file_path.exists()),
            Err(_) => {
                // Some implementations might require at least one page
                prop_assert!(true);
            }
        }
    }

    #[test]
    fn test_metadata_special_characters(
        title in prop::string::string_regex("[\\x00-\\x7F]{0,100}").unwrap()
    ) {
        let mut doc = Document::new();

        // Should handle any ASCII characters in metadata
        doc.set_title(&title);

        // Should not panic
        prop_assert!(true);
    }

    #[test]
    fn test_page_content_accumulation(lines in prop::collection::vec("[a-zA-Z0-9 ]{1,50}", 0..20)) {
        let mut page = Page::a4();
        let mut y = 700.0;

        // Add multiple lines of text
        for line in &lines {
            let result = page.text()
                .set_font(Font::Helvetica, 12.0)
                .at(50.0, y)
                .write(line);

            match result {
                Ok(_) => y -= 20.0,
                Err(_) => break, // Might run out of page space
            }
        }

        // Page should accumulate content
        prop_assert!(true);
    }
}

// Regression tests for specific document scenarios
#[cfg(test)]
mod regression_tests {
    use super::*;

    #[test]
    fn test_document_with_single_page() {
        let mut doc = Document::new();
        doc.add_page(Page::a4());

        assert_eq!(doc.pages.len(), 1);

        // Should save successfully
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("single_page.pdf");
        assert!(doc.save(&file_path).is_ok());
    }

    #[test]
    fn test_document_metadata_empty_strings() {
        let mut doc = Document::new();

        // Empty metadata should be valid
        doc.set_title("");
        doc.set_author("");
        doc.set_subject("");
        doc.set_keywords("");

        doc.add_page(Page::a4());

        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("empty_metadata.pdf");
        assert!(doc.save(&file_path).is_ok());
    }

    #[test]
    fn test_page_rotation_combinations() {
        let mut doc = Document::new();

        // Add pages with all rotation values
        for rotation in &[
            PageRotation::None,
            PageRotation::Rotate90,
            PageRotation::Rotate180,
            PageRotation::Rotate270,
        ] {
            let mut page = Page::a4();
            page.set_rotation(*rotation);
            doc.add_page(page);
        }

        assert_eq!(doc.pages.len(), 4);
    }

    #[test]
    fn test_large_metadata_strings() {
        let mut doc = Document::new();

        // Very long metadata
        let long_title = "A".repeat(1000);
        let long_author = "B".repeat(1000);

        doc.set_title(&long_title);
        doc.set_author(&long_author);
        doc.add_page(Page::a4());

        // Should handle long metadata gracefully
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("long_metadata.pdf");
        assert!(doc.save(&file_path).is_ok());
    }
}
