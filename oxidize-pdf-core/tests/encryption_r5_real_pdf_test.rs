/// Real PDF integration tests for AES-256 R5 encryption (Phase 4.2)
///
/// These tests validate our R5 implementation against real PDFs encrypted
/// with qpdf (--force-R5 option).
///
/// Test fixtures (generated by tests/fixtures/generate_r5_r6_pdfs.sh):
/// - encrypted_aes256_r5_user.pdf: user='user5', owner='owner5'
/// - encrypted_aes256_r5_empty_user.pdf: user='', owner='owner5_empty'
/// - encrypted_aes256_r5_unicode.pdf: user='unicode_contraseña', owner='owner5_unicode'
use oxidize_pdf::encryption::{StandardSecurityHandler, UserPassword};

const FIXTURES_DIR: &str = "tests/fixtures";

/// Test helper to read PDF bytes
fn read_pdf_bytes(filename: &str) -> Vec<u8> {
    let path = format!("{}/{}", FIXTURES_DIR, filename);
    std::fs::read(&path).expect(&format!("Failed to read {}", path))
}

/// Extract U entry bytes from PDF (48 bytes for R5/R6)
fn extract_u_entry(pdf_bytes: &[u8]) -> Option<Vec<u8>> {
    // Search for /U followed by hex string <...> or literal string (...)
    let pdf_str = String::from_utf8_lossy(pdf_bytes);

    // Find /U entry - in R5/R6 it's 48 bytes
    if let Some(pos) = pdf_str.find("/U ") {
        let start = pos + 3;
        // Skip whitespace
        let rest = &pdf_str[start..];

        if rest.starts_with('<') {
            // Hex string
            if let Some(end) = rest.find('>') {
                let hex = &rest[1..end];
                return Some(hex_to_bytes(hex));
            }
        } else if rest.starts_with('(') {
            // Literal string - more complex due to escapes
            return extract_literal_string(&rest);
        }
    }
    None
}

/// Extract UE entry bytes from PDF (32 bytes)
fn extract_ue_entry(pdf_bytes: &[u8]) -> Option<Vec<u8>> {
    let pdf_str = String::from_utf8_lossy(pdf_bytes);

    if let Some(pos) = pdf_str.find("/UE ") {
        let start = pos + 4;
        let rest = &pdf_str[start..];

        if rest.starts_with('<') {
            if let Some(end) = rest.find('>') {
                let hex = &rest[1..end];
                return Some(hex_to_bytes(hex));
            }
        } else if rest.starts_with('(') {
            return extract_literal_string(&rest);
        }
    }
    None
}

/// Extract encryption revision from PDF
fn extract_revision(pdf_bytes: &[u8]) -> Option<i32> {
    let pdf_str = String::from_utf8_lossy(pdf_bytes);

    // Find /R followed by integer
    for pattern in ["/R ", "/R\n", "/R\t"] {
        if let Some(pos) = pdf_str.find(pattern) {
            let start = pos + pattern.len();
            let rest = &pdf_str[start..];
            let end = rest
                .find(|c: char| !c.is_ascii_digit())
                .unwrap_or(rest.len());
            if let Ok(r) = rest[..end].parse() {
                return Some(r);
            }
        }
    }
    None
}

/// Convert hex string to bytes
fn hex_to_bytes(hex: &str) -> Vec<u8> {
    let clean: String = hex.chars().filter(|c| c.is_ascii_hexdigit()).collect();
    (0..clean.len())
        .step_by(2)
        .filter_map(|i| u8::from_str_radix(&clean[i..i + 2], 16).ok())
        .collect()
}

/// Extract literal string from PDF (handles escapes)
fn extract_literal_string(s: &str) -> Option<Vec<u8>> {
    if !s.starts_with('(') {
        return None;
    }

    let mut bytes = Vec::new();
    let mut chars = s[1..].chars().peekable();
    let mut depth = 1;

    while let Some(c) = chars.next() {
        if depth == 0 {
            break;
        }

        match c {
            '(' => {
                depth += 1;
                bytes.push(b'(');
            }
            ')' => {
                depth -= 1;
                if depth > 0 {
                    bytes.push(b')');
                }
            }
            '\\' => {
                match chars.next() {
                    Some('n') => bytes.push(b'\n'),
                    Some('r') => bytes.push(b'\r'),
                    Some('t') => bytes.push(b'\t'),
                    Some('b') => bytes.push(0x08),
                    Some('f') => bytes.push(0x0C),
                    Some('(') => bytes.push(b'('),
                    Some(')') => bytes.push(b')'),
                    Some('\\') => bytes.push(b'\\'),
                    Some(d) if d.is_ascii_digit() => {
                        // Octal escape
                        let mut oct = String::new();
                        oct.push(d);
                        for _ in 0..2 {
                            if chars
                                .peek()
                                .map(|&c| c.is_ascii_digit() && c < '8')
                                .unwrap_or(false)
                            {
                                oct.push(chars.next().unwrap());
                            }
                        }
                        if let Ok(val) = u8::from_str_radix(&oct, 8) {
                            bytes.push(val);
                        }
                    }
                    Some(other) => bytes.push(other as u8),
                    None => break,
                }
            }
            _ => bytes.push(c as u8),
        }
    }

    Some(bytes)
}

#[test]
fn test_r5_fixture_exists_and_readable() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r5_user.pdf");
    assert!(!pdf_bytes.is_empty(), "R5 fixture should not be empty");

    // Verify it's a PDF
    assert!(
        pdf_bytes.starts_with(b"%PDF-"),
        "Should be a valid PDF file"
    );
}

#[test]
fn test_r5_encryption_revision_detection() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r5_user.pdf");
    let revision = extract_revision(&pdf_bytes);

    assert_eq!(revision, Some(5), "Should be revision 5 (R5)");
}

#[test]
fn test_r5_u_entry_extraction() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r5_user.pdf");
    let u_entry = extract_u_entry(&pdf_bytes);

    assert!(u_entry.is_some(), "Should extract U entry from R5 PDF");
    let u = u_entry.unwrap();

    // R5 U entry should be 48 bytes (32 hash + 8 validation_salt + 8 key_salt)
    assert_eq!(
        u.len(),
        48,
        "R5 U entry should be 48 bytes, got {}",
        u.len()
    );
}

#[test]
fn test_r5_ue_entry_extraction() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r5_user.pdf");
    let ue_entry = extract_ue_entry(&pdf_bytes);

    assert!(ue_entry.is_some(), "Should extract UE entry from R5 PDF");
    let ue = ue_entry.unwrap();

    // R5 UE entry should be 32 bytes (encrypted file encryption key)
    assert_eq!(
        ue.len(),
        32,
        "R5 UE entry should be 32 bytes, got {}",
        ue.len()
    );
}

#[test]
fn test_r5_password_validation_correct() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r5_user.pdf");
    let u_entry = extract_u_entry(&pdf_bytes).expect("Should have U entry");

    let handler = StandardSecurityHandler::aes_256_r5();
    let correct_pwd = UserPassword("user5".to_string());

    let result = handler.validate_r5_user_password(&correct_pwd, &u_entry);
    assert!(
        result.is_ok(),
        "Validation should not error: {:?}",
        result.err()
    );
    assert!(
        result.unwrap(),
        "Correct password 'user5' should validate against R5 PDF"
    );
}

#[test]
fn test_r5_password_validation_incorrect() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r5_user.pdf");
    let u_entry = extract_u_entry(&pdf_bytes).expect("Should have U entry");

    let handler = StandardSecurityHandler::aes_256_r5();
    let wrong_pwd = UserPassword("wrong_password".to_string());

    let result = handler.validate_r5_user_password(&wrong_pwd, &u_entry);
    assert!(result.is_ok(), "Validation should not error");
    assert!(
        !result.unwrap(),
        "Wrong password should NOT validate against R5 PDF"
    );
}

#[test]
fn test_r5_empty_user_password() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r5_empty_user.pdf");
    let u_entry = extract_u_entry(&pdf_bytes).expect("Should have U entry");

    let handler = StandardSecurityHandler::aes_256_r5();
    let empty_pwd = UserPassword("".to_string());

    let result = handler.validate_r5_user_password(&empty_pwd, &u_entry);
    assert!(result.is_ok(), "Validation should not error");
    assert!(
        result.unwrap(),
        "Empty password should validate against R5 empty-user PDF"
    );
}

#[test]
fn test_r5_key_recovery() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r5_user.pdf");
    let u_entry = extract_u_entry(&pdf_bytes).expect("Should have U entry");
    let ue_entry = extract_ue_entry(&pdf_bytes).expect("Should have UE entry");

    let handler = StandardSecurityHandler::aes_256_r5();
    let correct_pwd = UserPassword("user5".to_string());

    let key_result = handler.recover_r5_encryption_key(&correct_pwd, &u_entry, &ue_entry);
    assert!(
        key_result.is_ok(),
        "Key recovery should not error: {:?}",
        key_result.err()
    );

    let key = key_result.unwrap();
    assert_eq!(
        key.key.len(),
        32,
        "Encryption key should be 32 bytes (256 bits)"
    );
}

#[test]
fn test_r5_unicode_password() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r5_unicode.pdf");
    let u_entry = extract_u_entry(&pdf_bytes).expect("Should have U entry");

    let handler = StandardSecurityHandler::aes_256_r5();
    let unicode_pwd = UserPassword("unicode_contraseña".to_string());

    let result = handler.validate_r5_user_password(&unicode_pwd, &u_entry);
    assert!(result.is_ok(), "Validation should not error with unicode");
    assert!(
        result.unwrap(),
        "Unicode password should validate against R5 unicode PDF"
    );
}
