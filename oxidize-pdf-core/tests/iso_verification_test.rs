//! Real ISO 32000-1:2008 Compliance Verification Tests
//!
//! These tests demonstrate the working verification system by:
//! 1. Loading the ISO compliance matrix
//! 2. Generating real PDFs  
//! 3. Parsing and verifying their structure
//! 4. Creating compliance reports

use oxidize_pdf::verification::{
    compliance_report::{format_report_markdown, generate_compliance_report},
    iso_matrix::load_default_matrix,
    parser::parse_pdf,
    validators::check_available_validators,
    verify_iso_requirement, IsoRequirement, VerificationLevel,
};
use oxidize_pdf::{Document, Font, Page, Result as PdfResult};

#[test]
fn test_real_iso_verification_system() -> PdfResult<()> {
    println!("ðŸ” Testing Real ISO Verification System");

    // Test 1: Check available external validators
    let available_validators = check_available_validators();
    println!("Available external validators: {:?}", available_validators);

    // Test 2: Generate a real PDF
    let mut doc = Document::new();
    doc.set_title("Real ISO Compliance Test");
    doc.set_author("oxidize-pdf verification system");

    let mut page = Page::a4();
    page.text()
        .set_font(Font::Helvetica, 16.0)
        .at(50.0, 750.0)
        .write("Real ISO 32000-1:2008 Compliance Test")?;

    page.text()
        .set_font(Font::TimesRoman, 12.0)
        .at(50.0, 700.0)
        .write("This PDF tests REAL compliance verification")?;

    page.text()
        .set_font(Font::Courier, 10.0)
        .at(50.0, 650.0)
        .write("Generated by oxidize-pdf with verification system")?;

    doc.add_page(page);
    let pdf_bytes = doc.to_bytes()?;

    println!("âœ“ Generated test PDF: {} bytes", pdf_bytes.len());

    // Test 3: Parse the generated PDF
    let parsed_pdf = parse_pdf(&pdf_bytes)?;
    println!("âœ“ Successfully parsed PDF");
    println!("  - Version: {}", parsed_pdf.version);
    println!("  - Objects: {}", parsed_pdf.object_count);
    println!("  - Fonts: {:?}", parsed_pdf.fonts);
    println!("  - XRef valid: {}", parsed_pdf.xref_valid);

    // Test 4: Verify catalog structure (ISO 7.5.2.1)
    if let Some(catalog) = &parsed_pdf.catalog {
        assert!(
            catalog.contains_key("Type"),
            "Catalog must have /Type entry"
        );
        assert_eq!(
            catalog.get("Type"),
            Some(&"Catalog".to_string()),
            "/Type must be /Catalog"
        );
        println!("âœ“ Catalog structure verified");
    } else {
        panic!("PDF must have document catalog");
    }

    // Test 5: Test specific ISO requirement verification
    let catalog_requirement = IsoRequirement {
        id: "7.5.2.1".to_string(),
        name: "Catalog Type Entry".to_string(),
        description: "Document catalog must have /Type /Catalog".to_string(),
        iso_reference: "7.5.2, Table 3.25".to_string(),
        implementation: Some("src/document.rs".to_string()),
        test_file: Some("tests/iso_verification_test.rs".to_string()),
        level: VerificationLevel::ContentVerified,
        verified: true,
        notes: "Real verification test".to_string(),
    };

    let verification_result = verify_iso_requirement(&pdf_bytes, &catalog_requirement)?;
    assert!(
        verification_result.passed,
        "ISO 7.5.2.1 verification should pass"
    );
    println!(
        "âœ“ ISO 7.5.2.1 verification: {}",
        verification_result.details
    );

    // Test 6: Test unimplemented requirement
    let version_requirement = IsoRequirement {
        id: "7.5.2.2".to_string(),
        name: "Catalog Version Entry".to_string(),
        description: "Optional /Version entry in catalog".to_string(),
        iso_reference: "7.5.2, Table 3.25".to_string(),
        implementation: None,
        test_file: None,
        level: VerificationLevel::NotImplemented,
        verified: false,
        notes: "Not implemented yet".to_string(),
    };

    let unimpl_result = verify_iso_requirement(&pdf_bytes, &version_requirement)?;
    assert!(
        !unimpl_result.passed,
        "Unimplemented feature should fail verification"
    );
    println!("âœ“ Correctly identified unimplemented feature");

    println!("ðŸŽ‰ Real ISO verification system is working correctly!");
    Ok(())
}

#[test]
fn test_compliance_matrix_loading() {
    println!("ðŸ” Testing ISO Compliance Matrix Loading");

    // Try to load the compliance matrix
    match load_default_matrix() {
        Ok(matrix) => {
            println!("âœ“ Successfully loaded ISO compliance matrix");
            println!("  - Version: {}", matrix.metadata.version);
            println!("  - Total features: {}", matrix.metadata.total_features);

            // Test matrix data access
            let all_requirements = matrix.get_all_requirements();
            println!("  - Total requirements loaded: {}", all_requirements.len());

            // Test statistics calculation
            let stats = matrix.calculate_compliance_stats();
            println!(
                "  - Average compliance: {:.1}%",
                stats.average_compliance_percentage
            );
            println!("  - Level 0 (Not implemented): {}", stats.level_0_count);
            println!("  - Level 4 (ISO compliant): {}", stats.level_4_count);

            // Test finding specific requirements
            if let Some(catalog_req) = matrix.get_requirement("7.5.2.1") {
                println!("  - Found requirement 7.5.2.1: {}", catalog_req.name);
                assert_eq!(catalog_req.level, VerificationLevel::ContentVerified);
            }

            println!("âœ“ Matrix data access working correctly");
        }
        Err(e) => {
            println!("âš ï¸  Could not load ISO compliance matrix: {}", e);
            println!("   This is expected if matrix file is not in the expected location");
            println!(
                "   The verification system can still work with manually created requirements"
            );
        }
    }
}

#[test]
fn test_compliance_report_generation() {
    println!("ðŸ” Testing Compliance Report Generation");

    // Create a minimal test matrix for report generation
    let test_matrix = create_test_compliance_matrix();

    let report = generate_compliance_report(&test_matrix);

    println!("âœ“ Generated compliance report");
    println!("  - Sections: {}", report.section_reports.len());
    println!("  - Recommendations: {}", report.recommendations.len());
    println!("  - Findings: {}", report.detailed_findings.len());

    // Test markdown formatting
    let markdown = format_report_markdown(&report);
    assert!(markdown.contains("# ISO 32000-1:2008 Compliance Report"));
    assert!(markdown.contains("Overall Compliance"));
    assert!(markdown.len() > 500); // Should be a substantial report

    println!("âœ“ Markdown report formatting working");
    println!("  - Report length: {} characters", markdown.len());

    // Print a sample of the report
    let lines: Vec<&str> = markdown.lines().take(20).collect();
    println!("ðŸ“‹ Sample report content:");
    for line in lines {
        if !line.trim().is_empty() {
            println!("   {}", line);
        }
    }
}

#[test]
fn test_pdf_comparison_system() -> PdfResult<()> {
    println!("ðŸ” Testing PDF Comparison System");

    // Generate two similar PDFs
    let mut doc1 = Document::new();
    let mut page1 = Page::a4();
    page1
        .text()
        .set_font(Font::Helvetica, 12.0)
        .at(100.0, 700.0)
        .write("Test Document A")?;
    doc1.add_page(page1);
    let pdf1_bytes = doc1.to_bytes()?;

    let mut doc2 = Document::new();
    let mut page2 = Page::a4();
    page2
        .text()
        .set_font(Font::Helvetica, 12.0)
        .at(100.0, 700.0)
        .write("Test Document B")?; // Different text
    doc2.add_page(page2);
    let pdf2_bytes = doc2.to_bytes()?;

    // Test PDF comparison
    use oxidize_pdf::verification::comparators::compare_pdfs;

    // Compare different PDFs
    let comparison = compare_pdfs(&pdf1_bytes, &pdf2_bytes)?;
    println!("âœ“ PDF comparison completed");
    println!(
        "  - Structurally equivalent: {}",
        comparison.structurally_equivalent
    );
    println!("  - Content equivalent: {}", comparison.content_equivalent);
    println!("  - Similarity score: {:.3}", comparison.similarity_score);
    println!("  - Differences found: {}", comparison.differences.len());

    // Compare identical PDFs
    let self_comparison = compare_pdfs(&pdf1_bytes, &pdf1_bytes)?;
    assert!(
        self_comparison.content_equivalent,
        "Identical PDFs should be content equivalent"
    );
    assert_eq!(
        self_comparison.similarity_score, 1.0,
        "Identical PDFs should have similarity score 1.0"
    );

    println!("âœ“ PDF comparison system working correctly");
    Ok(())
}

#[test]
fn test_verification_levels() -> PdfResult<()> {
    println!("ðŸ” Testing Verification Level System");

    // Generate test PDF with enough content
    let mut doc = Document::new();
    let mut page = Page::a4();
    page.text()
        .set_font(Font::Helvetica, 12.0)
        .at(100.0, 700.0)
        .write("Test Verification Content for ISO 32000-1:2008 Requirements")?;
    page.text()
        .set_font(Font::TimesRoman, 10.0)
        .at(100.0, 650.0)
        .write(
            "This PDF contains sufficient content to pass the GeneratesPdf verification level",
        )?;
    page.text()
        .set_font(Font::Courier, 8.0)
        .at(100.0, 600.0)
        .write(
        "Additional text to ensure the PDF file size exceeds the minimum threshold of 1000 bytes",
    )?;
    doc.add_page(page);
    let pdf_bytes = doc.to_bytes()?;

    // Test all verification levels
    let test_cases = vec![
        (
            VerificationLevel::NotImplemented,
            false,
            "Not implemented feature",
        ),
        (VerificationLevel::CodeExists, true, "API exists"),
        (VerificationLevel::GeneratesPdf, true, "Generates valid PDF"),
        (VerificationLevel::ContentVerified, true, "Content verified"),
        (
            VerificationLevel::IsoCompliant,
            false,
            "External validation (no tools available)",
        ),
    ];

    for (level, expected_pass, description) in test_cases {
        let requirement = IsoRequirement {
            id: format!("test.{}", level as u8),
            name: format!("Test {}", description),
            description: description.to_string(),
            iso_reference: "Test".to_string(),
            implementation: if level as u8 > 0 {
                Some("test".to_string())
            } else {
                None
            },
            test_file: Some("test".to_string()),
            level,
            verified: level as u8 >= 2,
            notes: "Test requirement".to_string(),
        };

        let result = verify_iso_requirement(&pdf_bytes, &requirement)?;

        println!(
            "  - Level {:?}: {} ({})",
            level,
            if result.passed { "âœ“" } else { "âœ—" },
            result.details
        );

        // Note: External validation (level 4) may fail due to missing tools, so we're flexible here
        if level != VerificationLevel::IsoCompliant {
            assert_eq!(
                result.passed,
                expected_pass,
                "Level {:?} should {} verification",
                level,
                if expected_pass { "pass" } else { "fail" }
            );
        }
    }

    println!("âœ“ Verification level system working correctly");
    Ok(())
}

// Helper function to create a test compliance matrix
fn create_test_compliance_matrix() -> oxidize_pdf::verification::iso_matrix::IsoMatrix {
    use oxidize_pdf::verification::iso_matrix::*;
    use std::collections::HashMap;

    let mut sections = HashMap::new();
    sections.insert(
        "test_section".to_string(),
        IsoSection {
            name: "Test Section".to_string(),
            iso_section: "Test".to_string(),
            total_requirements: 2,
            summary: SectionSummary {
                implemented: 1,
                average_level: 1.5,
                compliance_percentage: 37.5,
            },
            requirements: vec![
                IsoRequirementData {
                    id: "test.1".to_string(),
                    name: "Test Requirement 1".to_string(),
                    description: "A test requirement".to_string(),
                    iso_reference: "Test".to_string(),
                    implementation: "test".to_string(),
                    test_file: "test".to_string(),
                    level: 3,
                    verified: true,
                    external_validation: None,
                    notes: "Test".to_string(),
                },
                IsoRequirementData {
                    id: "test.2".to_string(),
                    name: "Test Requirement 2".to_string(),
                    description: "Another test requirement".to_string(),
                    iso_reference: "Test".to_string(),
                    implementation: "None".to_string(),
                    test_file: "None".to_string(),
                    level: 0,
                    verified: false,
                    external_validation: None,
                    notes: "Not implemented".to_string(),
                },
            ],
        },
    );

    IsoMatrix {
        metadata: MatrixMetadata {
            version: "test".to_string(),
            total_features: 2,
            specification: "Test".to_string(),
            methodology: "test".to_string(),
        },
        sections,
        overall_summary: OverallSummary {
            total_sections: 1,
            total_requirements: 2,
            total_implemented: 1,
            average_level: 1.5,
            real_compliance_percentage: 37.5,
            level_0_count: 1,
            level_1_count: 0,
            level_2_count: 0,
            level_3_count: 1,
            level_4_count: 0,
        },
        validation_tools: ValidationTools {
            external_validators: vec!["test".to_string()],
            internal_parser: true,
            reference_pdfs: false,
            automated_testing: false,
        },
    }
}
