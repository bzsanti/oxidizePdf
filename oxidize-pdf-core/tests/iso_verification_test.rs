//! Real ISO 32000-1:2008 Compliance Verification Tests
//!
//! These tests demonstrate the working verification system by:
//! 1. Loading the ISO compliance matrix
//! 2. Generating real PDFs  
//! 3. Parsing and verifying their structure
//! 4. Creating compliance reports

use oxidize_pdf::verification::{
    compliance_report::{format_report_markdown, generate_compliance_report},
    iso_matrix::load_compliance_system,
    parser::parse_pdf,
    validators::check_available_validators,
    verify_iso_requirement, IsoRequirement, VerificationLevel,
};
use oxidize_pdf::{Document, Font, Page, Result as PdfResult};

#[test]
fn test_real_iso_verification_system() -> PdfResult<()> {
    println!("üîç Testing Real ISO Verification System");

    // Test 1: Check available external validators
    let available_validators = check_available_validators();
    println!("Available external validators: {:?}", available_validators);

    // Test 2: Generate a real PDF
    let mut doc = Document::new();
    doc.set_title("Real ISO Compliance Test");
    doc.set_author("oxidize-pdf verification system");

    let mut page = Page::a4();
    page.text()
        .set_font(Font::Helvetica, 16.0)
        .at(50.0, 750.0)
        .write("Real ISO 32000-1:2008 Compliance Test")?;

    page.text()
        .set_font(Font::TimesRoman, 12.0)
        .at(50.0, 700.0)
        .write("This PDF tests REAL compliance verification")?;

    page.text()
        .set_font(Font::Courier, 10.0)
        .at(50.0, 650.0)
        .write("Generated by oxidize-pdf with verification system")?;

    doc.add_page(page);
    let pdf_bytes = doc.to_bytes()?;

    println!("‚úì Generated test PDF: {} bytes", pdf_bytes.len());

    // Test 3: Parse the generated PDF
    let parsed_pdf = parse_pdf(&pdf_bytes)?;
    println!("‚úì Successfully parsed PDF");
    println!("  - Version: {}", parsed_pdf.version);
    println!("  - Objects: {}", parsed_pdf.object_count);
    println!("  - Fonts: {:?}", parsed_pdf.fonts);
    println!("  - XRef valid: {}", parsed_pdf.xref_valid);

    // Test 4: Verify catalog structure (ISO 7.5.2.1)
    if let Some(catalog) = &parsed_pdf.catalog {
        assert!(
            catalog.contains_key("Type"),
            "Catalog must have /Type entry"
        );
        assert_eq!(
            catalog.get("Type"),
            Some(&"Catalog".to_string()),
            "/Type must be /Catalog"
        );
        println!("‚úì Catalog structure verified");
    } else {
        panic!("PDF must have document catalog");
    }

    // Test 5: Test specific ISO requirement verification
    let catalog_requirement = IsoRequirement {
        id: "7.5.2.1".to_string(),
        name: "Catalog Type Entry".to_string(),
        description: "Document catalog must have /Type /Catalog".to_string(),
        iso_reference: "7.5.2, Table 3.25".to_string(),
        implementation: Some("src/document.rs".to_string()),
        test_file: Some("tests/iso_verification_test.rs".to_string()),
        level: VerificationLevel::ContentVerified,
        verified: true,
        notes: "Real verification test".to_string(),
    };

    let verification_result = verify_iso_requirement(&pdf_bytes, &catalog_requirement)?;
    assert!(
        verification_result.passed,
        "ISO 7.5.2.1 verification should pass"
    );
    println!(
        "‚úì ISO 7.5.2.1 verification: {}",
        verification_result.details
    );

    // Test 6: Test unimplemented requirement
    let version_requirement = IsoRequirement {
        id: "7.5.2.2".to_string(),
        name: "Catalog Version Entry".to_string(),
        description: "Optional /Version entry in catalog".to_string(),
        iso_reference: "7.5.2, Table 3.25".to_string(),
        implementation: None,
        test_file: None,
        level: VerificationLevel::NotImplemented,
        verified: false,
        notes: "Not implemented yet".to_string(),
    };

    let unimpl_result = verify_iso_requirement(&pdf_bytes, &version_requirement)?;
    assert!(
        !unimpl_result.passed,
        "Unimplemented feature should fail verification"
    );
    println!("‚úì Correctly identified unimplemented feature");

    println!("üéâ Real ISO verification system is working correctly!");
    Ok(())
}

#[test]
fn test_compliance_matrix_loading() {
    println!("üîç Testing ISO Compliance Matrix Loading");

    // Try to load the complete compliance system
    match load_compliance_system() {
        Ok(system) => {
            println!("‚úì Successfully loaded ISO compliance system");
            println!("  - Version: {}", system.matrix.metadata.version);
            println!(
                "  - Total features: {}",
                system.matrix.metadata.total_features
            );

            // Test system data access using new methods
            let all_requirements = system.get_all_requirements();
            println!("  - Total requirements loaded: {}", all_requirements.len());

            // Test statistics calculation using new method
            let stats = system.calculate_compliance_stats();
            println!(
                "  - Average compliance: {:.1}%",
                stats.average_compliance_percentage
            );
            println!("  - Level 0 (Not implemented): {}", stats.level_0_count);
            println!("  - Level 4 (ISO compliant): {}", stats.level_4_count);

            // Test finding specific requirements using new method
            if let Some(catalog_req) = system.get_requirement_info("7.5.2.1") {
                println!("  - Found requirement 7.5.2.1: {}", catalog_req.name);
            }

            println!("‚úì Matrix data access working correctly");
        }
        Err(e) => {
            println!("‚ö†Ô∏è  Could not load ISO compliance matrix: {}", e);
            println!("   This is expected if matrix file is not in the expected location");
            println!(
                "   The verification system can still work with manually created requirements"
            );
        }
    }
}

#[test]
fn test_compliance_report_generation() {
    println!("üîç Testing Compliance Report Generation");

    // Create a minimal test matrix for report generation
    let test_matrix = create_test_compliance_matrix();

    let report = generate_compliance_report(&test_matrix);

    println!("‚úì Generated compliance report");
    println!("  - Sections: {}", report.section_reports.len());
    println!("  - Recommendations: {}", report.recommendations.len());
    println!("  - Findings: {}", report.detailed_findings.len());

    // Test markdown formatting
    let markdown = format_report_markdown(&report);
    assert!(markdown.contains("# ISO 32000-1:2008 Compliance Report"));
    assert!(markdown.contains("Overall Compliance"));
    assert!(markdown.len() > 500); // Should be a substantial report

    println!("‚úì Markdown report formatting working");
    println!("  - Report length: {} characters", markdown.len());

    // Print a sample of the report
    let lines: Vec<&str> = markdown.lines().take(20).collect();
    println!("üìã Sample report content:");
    for line in lines {
        if !line.trim().is_empty() {
            println!("   {}", line);
        }
    }
}

#[test]
fn test_pdf_comparison_system() -> PdfResult<()> {
    println!("üîç Testing PDF Comparison System");

    // Generate two similar PDFs
    let mut doc1 = Document::new();
    let mut page1 = Page::a4();
    page1
        .text()
        .set_font(Font::Helvetica, 12.0)
        .at(100.0, 700.0)
        .write("Test Document A")?;
    doc1.add_page(page1);
    let pdf1_bytes = doc1.to_bytes()?;

    let mut doc2 = Document::new();
    let mut page2 = Page::a4();
    page2
        .text()
        .set_font(Font::Helvetica, 12.0)
        .at(100.0, 700.0)
        .write("Test Document B")?; // Different text
    doc2.add_page(page2);
    let pdf2_bytes = doc2.to_bytes()?;

    // Test PDF comparison
    use oxidize_pdf::verification::comparators::compare_pdfs;

    // Compare different PDFs
    let comparison = compare_pdfs(&pdf1_bytes, &pdf2_bytes)?;
    println!("‚úì PDF comparison completed");
    println!(
        "  - Structurally equivalent: {}",
        comparison.structurally_equivalent
    );
    println!("  - Content equivalent: {}", comparison.content_equivalent);
    println!("  - Similarity score: {:.3}", comparison.similarity_score);
    println!("  - Differences found: {}", comparison.differences.len());

    // Compare identical PDFs
    let self_comparison = compare_pdfs(&pdf1_bytes, &pdf1_bytes)?;
    assert!(
        self_comparison.content_equivalent,
        "Identical PDFs should be content equivalent"
    );
    assert_eq!(
        self_comparison.similarity_score, 1.0,
        "Identical PDFs should have similarity score 1.0"
    );

    println!("‚úì PDF comparison system working correctly");
    Ok(())
}

#[test]
fn test_verification_levels() -> PdfResult<()> {
    println!("üîç Testing Verification Level System");

    // Generate test PDF with enough content
    let mut doc = Document::new();
    let mut page = Page::a4();
    page.text()
        .set_font(Font::Helvetica, 12.0)
        .at(100.0, 700.0)
        .write("Test Verification Content for ISO 32000-1:2008 Requirements")?;
    page.text()
        .set_font(Font::TimesRoman, 10.0)
        .at(100.0, 650.0)
        .write(
            "This PDF contains sufficient content to pass the GeneratesPdf verification level",
        )?;
    page.text()
        .set_font(Font::Courier, 8.0)
        .at(100.0, 600.0)
        .write(
        "Additional text to ensure the PDF file size exceeds the minimum threshold of 1000 bytes",
    )?;
    doc.add_page(page);
    let pdf_bytes = doc.to_bytes()?;

    // Test all verification levels
    let test_cases = vec![
        (
            VerificationLevel::NotImplemented,
            false,
            "Not implemented feature",
        ),
        (VerificationLevel::CodeExists, true, "API exists"),
        (VerificationLevel::GeneratesPdf, true, "Generates valid PDF"),
        (VerificationLevel::ContentVerified, true, "Content verified"),
        (
            VerificationLevel::IsoCompliant,
            false,
            "External validation (no tools available)",
        ),
    ];

    for (level, expected_pass, description) in test_cases {
        let requirement = IsoRequirement {
            id: format!("test.{}", level as u8),
            name: format!("Test {}", description),
            description: description.to_string(),
            iso_reference: "Test".to_string(),
            implementation: if level as u8 > 0 {
                Some("test".to_string())
            } else {
                None
            },
            test_file: Some("test".to_string()),
            level,
            verified: level as u8 >= 2,
            notes: "Test requirement".to_string(),
        };

        let result = verify_iso_requirement(&pdf_bytes, &requirement)?;

        println!(
            "  - Level {:?}: {} ({})",
            level,
            if result.passed { "‚úì" } else { "‚úó" },
            result.details
        );

        // Note: External validation (level 4) may fail due to missing tools, so we're flexible here
        if level != VerificationLevel::IsoCompliant {
            assert_eq!(
                result.passed,
                expected_pass,
                "Level {:?} should {} verification",
                level,
                if expected_pass { "pass" } else { "fail" }
            );
        }
    }

    println!("‚úì Verification level system working correctly");
    Ok(())
}

// Helper function to create a test compliance matrix
fn create_test_compliance_matrix() -> oxidize_pdf::verification::iso_matrix::IsoMatrix {
    use oxidize_pdf::verification::iso_matrix::*;
    use std::collections::HashMap;

    let mut sections = HashMap::new();
    sections.insert(
        "test_section".to_string(),
        IsoSection {
            name: "Test Section".to_string(),
            iso_section: "Test".to_string(),
            total_requirements: 2,
            summary: SectionSummary {
                implemented: 1,
                average_level: 1.5,
                compliance_percentage: 37.5,
            },
            requirements: vec![
                IsoRequirementData {
                    id: "test.1".to_string(),
                    name: "Test Requirement 1".to_string(),
                    description: "A test requirement".to_string(),
                    iso_reference: "Test".to_string(),
                    requirement_type: "mandatory".to_string(),
                    page: 42,
                    original_text: "Test requirement original text from ISO standard".to_string(),
                },
                IsoRequirementData {
                    id: "test.2".to_string(),
                    name: "Test Requirement 2".to_string(),
                    description: "Another test requirement".to_string(),
                    iso_reference: "Test".to_string(),
                    requirement_type: "optional".to_string(),
                    page: 43,
                    original_text: "Another test requirement original text from ISO standard"
                        .to_string(),
                },
            ],
        },
    );

    IsoMatrix {
        metadata: MatrixMetadata {
            version: "test".to_string(),
            total_features: 2,
            specification: "Test".to_string(),
            methodology: "test".to_string(),
        },
        sections,
        overall_summary: OverallSummary {
            total_sections: 1,
            total_requirements: 2,
            total_implemented: 1,
            average_level: 1.5,
            real_compliance_percentage: 37.5,
            level_0_count: 1,
            level_1_count: 0,
            level_2_count: 0,
            level_3_count: 1,
            level_4_count: 0,
        },
        validation_tools: ValidationTools {
            external_validators: vec!["test".to_string()],
            internal_parser: true,
            reference_pdfs: false,
            automated_testing: false,
        },
    }
}

#[test]
fn test_requirement_status_handling() {
    println!("üîç Testing RequirementStatus handling (external validation & notes)");

    use oxidize_pdf::verification::iso_matrix::RequirementStatus;
    use std::collections::HashMap;

    // Create test status data with external validation and notes
    let mut status_map = HashMap::new();

    // Test requirement with external validation success
    status_map.insert(
        "test.1".to_string(),
        RequirementStatus {
            level: 3,
            implementation: "src/test.rs".to_string(),
            test_file: "tests/iso_verification_test.rs".to_string(),
            verified: true,
            last_checked: "2025-08-24T10:00:00Z".to_string(),
            notes:
                "External validation: qpdf confirms compliance. Tested with various text encodings."
                    .to_string(),
        },
    );

    // Test requirement with external validation pending
    status_map.insert(
        "test.2".to_string(),
        RequirementStatus {
            level: 2,
            implementation: "None".to_string(),
            test_file: "None".to_string(),
            verified: false,
            last_checked: "2025-08-24T10:00:00Z".to_string(),
            notes: "External validation: Pending qpdf installation. Internal tests pass."
                .to_string(),
        },
    );

    // Verify status data structure
    assert_eq!(status_map.len(), 2);

    let status1 = status_map.get("test.1").unwrap();
    assert!(status1.verified);
    assert!(status1.notes.contains("External validation"));
    assert!(status1.notes.contains("qpdf"));

    let status2 = status_map.get("test.2").unwrap();
    assert!(!status2.verified);
    assert!(status2.notes.contains("External validation: Pending"));

    println!("‚úì External validation tracking working");
    println!("  - Status with external validation: {}", status1.notes);
    println!("  - Status with pending validation: {}", status2.notes);

    // Test notes parsing for external validation results
    let has_external_validation =
        |notes: &str| -> bool { notes.to_lowercase().contains("external validation") };

    let extract_external_tool = |notes: &str| -> Option<String> {
        if notes.contains("qpdf") {
            Some("qpdf".to_string())
        } else if notes.contains("adobe") {
            Some("adobe_preflight".to_string())
        } else if notes.contains("veraPDF") {
            Some("veraPDF".to_string())
        } else {
            None
        }
    };

    assert!(has_external_validation(&status1.notes));
    assert_eq!(
        extract_external_tool(&status1.notes),
        Some("qpdf".to_string())
    );

    println!("‚úì Notes parsing for external validation working correctly");
}

#[test]
fn test_compliance_system_dual_file_architecture() {
    println!("üîç Testing ComplianceSystem dual-file architecture");

    use oxidize_pdf::verification::iso_matrix::*;
    use std::collections::HashMap;

    // Create test matrix (immutable definitions)
    let matrix = create_test_compliance_matrix();

    // Create test verification status (mutable state)
    let mut status_map = HashMap::new();
    status_map.insert(
        "test.1".to_string(),
        RequirementStatus {
            level: 3,
            implementation: "src/document.rs:125".to_string(),
            test_file: "tests/iso_verification_test.rs:77".to_string(),
            verified: true,
            last_checked: "2025-08-24T10:00:00Z".to_string(),
            notes: "Level 3: Content verified. External validation: qpdf confirms /Type /Catalog structure.".to_string(),
        },
    );

    status_map.insert(
        "test.2".to_string(),
        RequirementStatus {
            level: 0,
            implementation: "None".to_string(),
            test_file: "None".to_string(),
            verified: false,
            last_checked: "2025-08-24T10:00:00Z".to_string(),
            notes: "Level 0: Not implemented. External validation: N/A (feature not available)."
                .to_string(),
        },
    );

    let verification_status = VerificationStatus {
        metadata: StatusMetadata {
            last_updated: "2025-08-24T10:00:00Z".to_string(),
            matrix_version: "test".to_string(),
            total_requirements: 2,
            note: "Test verification status".to_string(),
            warning: "For testing purposes only".to_string(),
        },
        status: status_map,
        statistics: StatusStatistics {
            level_0_count: 1,
            level_1_count: 0,
            level_2_count: 0,
            level_3_count: 1,
            level_4_count: 0,
            average_level: 1.5,
            compliance_percentage: 37.5,
            last_calculated: "2025-08-24T10:00:00Z".to_string(),
        },
    };

    // Create combined compliance system
    let compliance_system = ComplianceSystem {
        matrix,
        status: verification_status,
    };

    // Test dual-file system functionality
    println!("‚úì ComplianceSystem created successfully");
    println!(
        "  - Matrix version: {}",
        compliance_system.matrix.metadata.version
    );
    println!(
        "  - Status last updated: {}",
        compliance_system.status.metadata.last_updated
    );
    println!(
        "  - Total requirements: {}",
        compliance_system.status.metadata.total_requirements
    );

    // Test combining matrix definitions with status data
    let req_data = compliance_system
        .matrix
        .sections
        .get("test_section")
        .unwrap()
        .requirements.first()
        .unwrap();
    let req_status = compliance_system.status.status.get("test.1").unwrap();

    println!("‚úì Requirement combination test:");
    println!(
        "  - Definition: {} ({})",
        req_data.name, req_data.requirement_type
    );
    println!(
        "  - Status: Level {} - {}",
        req_status.level,
        if req_status.verified {
            "Verified"
        } else {
            "Not verified"
        }
    );
    println!("  - Implementation: {}", req_status.implementation);
    println!("  - Notes: {}", req_status.notes);

    // Verify separation of concerns
    assert!(!req_data.name.is_empty()); // Matrix has definitions
    assert!(!req_status.implementation.is_empty() || req_status.implementation == "None"); // Status has implementation details
    assert!(!req_status.notes.is_empty()); // Status has verification notes

    // Test external validation tracking through notes
    let has_external_validation = req_status.notes.contains("External validation:");
    let external_validation_passed = req_status.notes.contains("qpdf confirms");

    assert!(has_external_validation);
    assert!(external_validation_passed);

    println!("‚úì External validation tracking through notes working");
    println!("‚úì Dual-file architecture test passed - proper separation of concerns");
}
