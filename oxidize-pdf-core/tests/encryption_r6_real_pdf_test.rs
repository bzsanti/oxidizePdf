/// Real PDF integration tests for AES-256 R6 encryption (Phase 4.3)
///
/// These tests validate our R6 implementation against real PDFs encrypted
/// with qpdf (default 256-bit uses R6).
///
/// Test fixtures (generated by tests/fixtures/generate_r5_r6_pdfs.sh):
/// - encrypted_aes256_r6_user.pdf: user='user6', owner='owner6'
/// - encrypted_aes256_r6_empty_user.pdf: user='', owner='owner6_empty'
/// - encrypted_aes256_r6_unicode.pdf: user='cafÃ©ðŸ”’', owner='owner6_unicode'
use oxidize_pdf::encryption::{StandardSecurityHandler, UserPassword};

const FIXTURES_DIR: &str = "tests/fixtures";

/// Test helper to read PDF bytes
fn read_pdf_bytes(filename: &str) -> Vec<u8> {
    let path = format!("{}/{}", FIXTURES_DIR, filename);
    std::fs::read(&path).expect(&format!("Failed to read {}", path))
}

/// Extract U entry bytes from PDF (48 bytes for R5/R6)
fn extract_u_entry(pdf_bytes: &[u8]) -> Option<Vec<u8>> {
    let pdf_str = String::from_utf8_lossy(pdf_bytes);

    if let Some(pos) = pdf_str.find("/U ") {
        let start = pos + 3;
        let rest = &pdf_str[start..];

        if rest.starts_with('<') {
            if let Some(end) = rest.find('>') {
                let hex = &rest[1..end];
                return Some(hex_to_bytes(hex));
            }
        } else if rest.starts_with('(') {
            return extract_literal_string(&rest);
        }
    }
    None
}

/// Extract UE entry bytes from PDF (32 bytes)
fn extract_ue_entry(pdf_bytes: &[u8]) -> Option<Vec<u8>> {
    let pdf_str = String::from_utf8_lossy(pdf_bytes);

    if let Some(pos) = pdf_str.find("/UE ") {
        let start = pos + 4;
        let rest = &pdf_str[start..];

        if rest.starts_with('<') {
            if let Some(end) = rest.find('>') {
                let hex = &rest[1..end];
                return Some(hex_to_bytes(hex));
            }
        } else if rest.starts_with('(') {
            return extract_literal_string(&rest);
        }
    }
    None
}

/// Extract Perms entry bytes from PDF (16 bytes, R6 only)
fn extract_perms_entry(pdf_bytes: &[u8]) -> Option<Vec<u8>> {
    let pdf_str = String::from_utf8_lossy(pdf_bytes);

    if let Some(pos) = pdf_str.find("/Perms ") {
        let start = pos + 7;
        let rest = &pdf_str[start..];

        if rest.starts_with('<') {
            if let Some(end) = rest.find('>') {
                let hex = &rest[1..end];
                return Some(hex_to_bytes(hex));
            }
        } else if rest.starts_with('(') {
            return extract_literal_string(&rest);
        }
    }
    None
}

/// Extract encryption revision from PDF
fn extract_revision(pdf_bytes: &[u8]) -> Option<i32> {
    let pdf_str = String::from_utf8_lossy(pdf_bytes);

    for pattern in ["/R ", "/R\n", "/R\t"] {
        if let Some(pos) = pdf_str.find(pattern) {
            let start = pos + pattern.len();
            let rest = &pdf_str[start..];
            let end = rest
                .find(|c: char| !c.is_ascii_digit())
                .unwrap_or(rest.len());
            if let Ok(r) = rest[..end].parse() {
                return Some(r);
            }
        }
    }
    None
}

/// Convert hex string to bytes
fn hex_to_bytes(hex: &str) -> Vec<u8> {
    let clean: String = hex.chars().filter(|c| c.is_ascii_hexdigit()).collect();
    (0..clean.len())
        .step_by(2)
        .filter_map(|i| u8::from_str_radix(&clean[i..i + 2], 16).ok())
        .collect()
}

/// Extract literal string from PDF (handles escapes)
fn extract_literal_string(s: &str) -> Option<Vec<u8>> {
    if !s.starts_with('(') {
        return None;
    }

    let mut bytes = Vec::new();
    let mut chars = s[1..].chars().peekable();
    let mut depth = 1;

    while let Some(c) = chars.next() {
        if depth == 0 {
            break;
        }

        match c {
            '(' => {
                depth += 1;
                bytes.push(b'(');
            }
            ')' => {
                depth -= 1;
                if depth > 0 {
                    bytes.push(b')');
                }
            }
            '\\' => match chars.next() {
                Some('n') => bytes.push(b'\n'),
                Some('r') => bytes.push(b'\r'),
                Some('t') => bytes.push(b'\t'),
                Some('b') => bytes.push(0x08),
                Some('f') => bytes.push(0x0C),
                Some('(') => bytes.push(b'('),
                Some(')') => bytes.push(b')'),
                Some('\\') => bytes.push(b'\\'),
                Some(d) if d.is_ascii_digit() => {
                    let mut oct = String::new();
                    oct.push(d);
                    for _ in 0..2 {
                        if chars
                            .peek()
                            .map(|&c| c.is_ascii_digit() && c < '8')
                            .unwrap_or(false)
                        {
                            oct.push(chars.next().unwrap());
                        }
                    }
                    if let Ok(val) = u8::from_str_radix(&oct, 8) {
                        bytes.push(val);
                    }
                }
                Some(other) => bytes.push(other as u8),
                None => break,
            },
            _ => bytes.push(c as u8),
        }
    }

    Some(bytes)
}

#[test]
fn test_r6_fixture_exists_and_readable() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r6_user.pdf");
    assert!(!pdf_bytes.is_empty(), "R6 fixture should not be empty");

    // Verify it's a PDF
    assert!(
        pdf_bytes.starts_with(b"%PDF-"),
        "Should be a valid PDF file"
    );
}

#[test]
fn test_r6_encryption_revision_detection() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r6_user.pdf");
    let revision = extract_revision(&pdf_bytes);

    assert_eq!(revision, Some(6), "Should be revision 6 (R6)");
}

#[test]
fn test_r6_u_entry_extraction() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r6_user.pdf");
    let u_entry = extract_u_entry(&pdf_bytes);

    assert!(u_entry.is_some(), "Should extract U entry from R6 PDF");
    let u = u_entry.unwrap();

    // R6 U entry should be 48 bytes (32 hash + 8 validation_salt + 8 key_salt)
    assert_eq!(
        u.len(),
        48,
        "R6 U entry should be 48 bytes, got {}",
        u.len()
    );
}

#[test]
fn test_r6_ue_entry_extraction() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r6_user.pdf");
    let ue_entry = extract_ue_entry(&pdf_bytes);

    assert!(ue_entry.is_some(), "Should extract UE entry from R6 PDF");
    let ue = ue_entry.unwrap();

    // R6 UE entry should be 32 bytes
    assert_eq!(
        ue.len(),
        32,
        "R6 UE entry should be 32 bytes, got {}",
        ue.len()
    );
}

#[test]
fn test_r6_perms_entry_extraction() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r6_user.pdf");
    let perms = extract_perms_entry(&pdf_bytes);

    assert!(perms.is_some(), "R6 should have Perms entry");
    let p = perms.unwrap();

    // R6 Perms entry should be 16 bytes (AES-ECB encrypted permissions)
    assert_eq!(
        p.len(),
        16,
        "R6 Perms entry should be 16 bytes, got {}",
        p.len()
    );
}

/// NOTE: This test requires full Algorithm 2.B implementation (ISO 32000-2:2020)
/// Current implementation uses a simplified hash loop that doesn't match qpdf's output.
/// Algorithm 2.B uses AES-128-CBC + rotating SHA-256/384/512 based on round number.
#[test]
#[ignore = "Requires Algorithm 2.B implementation for R6 - tracked in TDD plan"]
fn test_r6_password_validation_correct() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r6_user.pdf");
    let u_entry = extract_u_entry(&pdf_bytes).expect("Should have U entry");

    let handler = StandardSecurityHandler::aes_256_r6();
    let correct_pwd = UserPassword("user6".to_string());

    let result = handler.validate_r6_user_password(&correct_pwd, &u_entry);
    assert!(
        result.is_ok(),
        "Validation should not error: {:?}",
        result.err()
    );
    assert!(
        result.unwrap(),
        "Correct password 'user6' should validate against R6 PDF"
    );
}

#[test]
fn test_r6_password_validation_incorrect() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r6_user.pdf");
    let u_entry = extract_u_entry(&pdf_bytes).expect("Should have U entry");

    let handler = StandardSecurityHandler::aes_256_r6();
    let wrong_pwd = UserPassword("wrong_password".to_string());

    let result = handler.validate_r6_user_password(&wrong_pwd, &u_entry);
    assert!(result.is_ok(), "Validation should not error");
    assert!(
        !result.unwrap(),
        "Wrong password should NOT validate against R6 PDF"
    );
}

#[test]
#[ignore = "Requires Algorithm 2.B implementation for R6 - tracked in TDD plan"]
fn test_r6_empty_user_password() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r6_empty_user.pdf");
    let u_entry = extract_u_entry(&pdf_bytes).expect("Should have U entry");

    let handler = StandardSecurityHandler::aes_256_r6();
    let empty_pwd = UserPassword("".to_string());

    let result = handler.validate_r6_user_password(&empty_pwd, &u_entry);
    assert!(result.is_ok(), "Validation should not error");
    assert!(
        result.unwrap(),
        "Empty password should validate against R6 empty-user PDF"
    );
}

#[test]
fn test_r6_key_recovery() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r6_user.pdf");
    let u_entry = extract_u_entry(&pdf_bytes).expect("Should have U entry");
    let ue_entry = extract_ue_entry(&pdf_bytes).expect("Should have UE entry");

    let handler = StandardSecurityHandler::aes_256_r6();
    let correct_pwd = UserPassword("user6".to_string());

    let key_result = handler.recover_r6_encryption_key(&correct_pwd, &u_entry, &ue_entry);
    assert!(
        key_result.is_ok(),
        "Key recovery should not error: {:?}",
        key_result.err()
    );

    let key = key_result.unwrap();
    assert_eq!(
        key.key.len(),
        32,
        "Encryption key should be 32 bytes (256 bits)"
    );
}

#[test]
#[ignore = "Requires Algorithm 2.B implementation for R6 - tracked in TDD plan"]
fn test_r6_unicode_password() {
    let pdf_bytes = read_pdf_bytes("encrypted_aes256_r6_unicode.pdf");
    let u_entry = extract_u_entry(&pdf_bytes).expect("Should have U entry");

    let handler = StandardSecurityHandler::aes_256_r6();
    // Note: qpdf uses UTF-8 encoding for unicode passwords
    let unicode_pwd = UserPassword("cafÃ©ðŸ”’".to_string());

    let result = handler.validate_r6_user_password(&unicode_pwd, &u_entry);
    assert!(result.is_ok(), "Validation should not error with unicode");
    assert!(
        result.unwrap(),
        "Unicode password should validate against R6 unicode PDF"
    );
}
