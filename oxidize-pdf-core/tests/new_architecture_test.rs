//! Integration test for the new PdfDocument architecture

use oxidize_pdf_core::parser::{PdfReader, PdfDocument};
use oxidize_pdf_core::operations::{split_pdf, merge_pdf_files, rotate_pdf_pages};
use oxidize_pdf_core::operations::{SplitOptions, SplitMode, RotationAngle, RotateOptions};
use oxidize_pdf_core::{Document, Page};
use std::fs;
use tempfile::TempDir;

#[test]
fn test_pdf_document_page_access() {
    // Create a test PDF
    let temp_dir = TempDir::new().unwrap();
    let test_pdf = temp_dir.path().join("test.pdf");
    
    // Create a simple PDF with 3 pages
    let mut doc = Document::new();
    doc.set_title("Test Document");
    
    for i in 1..=3 {
        let mut page = Page::new(612.0, 792.0);
        page.text()
            .set_font(oxidize_pdf_core::text::Font::Helvetica, 12.0)
            .at(100.0, 700.0)
            .write(&format!("Page {}", i))
            .unwrap();
        doc.add_page(page);
    }
    
    doc.save(&test_pdf).unwrap();
    
    // Now open it with the new architecture
    let document = PdfReader::open_document(&test_pdf).unwrap();
    
    // Test metadata access
    let metadata = document.metadata().unwrap();
    assert_eq!(metadata.title, Some("Test Document".to_string()));
    
    // Test page count
    let page_count = document.page_count().unwrap();
    assert_eq!(page_count, 3);
    
    // Test page access
    for i in 0..3 {
        let page = document.get_page(i).unwrap();
        assert_eq!(page.width(), 612.0);
        assert_eq!(page.height(), 792.0);
    }
}

#[test]
fn test_split_operation_with_new_architecture() {
    // Create a test PDF
    let temp_dir = TempDir::new().unwrap();
    let test_pdf = temp_dir.path().join("test_split.pdf");
    
    // Create a simple PDF with 5 pages
    let mut doc = Document::new();
    doc.set_title("Split Test");
    
    for i in 1..=5 {
        let mut page = Page::new(612.0, 792.0);
        page.text()
            .set_font(oxidize_pdf_core::text::Font::Helvetica, 12.0)
            .at(100.0, 700.0)
            .write(&format!("Split Page {}", i))
            .unwrap();
        doc.add_page(page);
    }
    
    doc.save(&test_pdf).unwrap();
    
    // Split into single pages
    let output_pattern = temp_dir.path().join("page_{}.pdf").to_str().unwrap().to_string();
    let options = SplitOptions {
        mode: SplitMode::SinglePages,
        output_pattern,
        ..Default::default()
    };
    
    let output_files = split_pdf(&test_pdf, options).unwrap();
    assert_eq!(output_files.len(), 5);
    
    // Verify each output file exists
    for (i, output_file) in output_files.iter().enumerate() {
        assert!(output_file.exists(), "Output file {} should exist", i);
        
        // Open and verify it has one page
        let doc = PdfReader::open_document(&output_file).unwrap();
        assert_eq!(doc.page_count().unwrap(), 1);
    }
}

#[test]
fn test_merge_operation_with_new_architecture() {
    // Create test PDFs
    let temp_dir = TempDir::new().unwrap();
    let mut input_files = vec![];
    
    // Create 3 PDFs with 2 pages each
    for i in 0..3 {
        let test_pdf = temp_dir.path().join(format!("merge_input_{}.pdf", i));
        
        let mut doc = Document::new();
        doc.set_title(&format!("Merge Test {}", i));
        
        for j in 1..=2 {
            let mut page = Page::new(612.0, 792.0);
            page.text()
                .set_font(oxidize_pdf_core::text::Font::Helvetica, 12.0)
                .at(100.0, 700.0)
                .write(&format!("Document {} Page {}", i + 1, j))
                .unwrap();
            doc.add_page(page);
        }
        
        doc.save(&test_pdf).unwrap();
        input_files.push(test_pdf);
    }
    
    // Merge them
    let output_pdf = temp_dir.path().join("merged.pdf");
    merge_pdf_files(&input_files, &output_pdf).unwrap();
    
    // Verify the merged PDF
    let document = PdfReader::open_document(&output_pdf).unwrap();
    assert_eq!(document.page_count().unwrap(), 6); // 3 files * 2 pages each
    
    // Check metadata is from first file
    let metadata = document.metadata().unwrap();
    assert_eq!(metadata.title, Some("Merge Test 0".to_string()));
}

#[test]
fn test_rotate_operation_with_new_architecture() {
    // Create a test PDF
    let temp_dir = TempDir::new().unwrap();
    let test_pdf = temp_dir.path().join("test_rotate.pdf");
    
    // Create a simple PDF with 3 pages
    let mut doc = Document::new();
    doc.set_title("Rotate Test");
    
    for i in 1..=3 {
        let mut page = Page::new(612.0, 792.0);
        page.text()
            .set_font(oxidize_pdf_core::text::Font::Helvetica, 12.0)
            .at(100.0, 700.0)
            .write(&format!("Rotate Page {}", i))
            .unwrap();
            
        // Add a rectangle to see rotation
        page.graphics()
            .set_stroke_color(oxidize_pdf_core::graphics::Color::Rgb(1.0, 0.0, 0.0))
            .rect(50.0, 50.0, 100.0, 200.0)
            .stroke();
        doc.add_page(page);
    }
    
    doc.save(&test_pdf).unwrap();
    
    // Rotate all pages 90 degrees
    let output_pdf = temp_dir.path().join("rotated.pdf");
    let options = RotateOptions {
        angle: RotationAngle::Clockwise90,
        ..Default::default()
    };
    rotate_pdf_pages(&test_pdf, &output_pdf, options).unwrap();
    
    // Verify the rotated PDF
    let document = PdfReader::open_document(&output_pdf).unwrap();
    assert_eq!(document.page_count().unwrap(), 3);
    
    // The rotated pages should have swapped dimensions if preserve_page_size is false
    // Since our default doesn't preserve page size, a 612x792 page rotated 90 degrees
    // should become 792x612
    // However, our current implementation might not reflect this properly in parsed pages
}

#[test]
fn test_resource_caching() {
    // Create a test PDF
    let temp_dir = TempDir::new().unwrap();
    let test_pdf = temp_dir.path().join("test_cache.pdf");
    
    let mut doc = Document::new();
    let mut page = Page::new(612.0, 792.0);
    page.text()
        .set_font(oxidize_pdf_core::text::Font::Helvetica, 12.0)
        .at(100.0, 700.0)
        .write("Cache Test")
        .unwrap();
    doc.add_page(page);
    
    doc.save(&test_pdf).unwrap();
    
    // Open with new architecture
    let document = PdfReader::open_document(&test_pdf).unwrap();
    
    // Access the same page multiple times - should use cache
    let page1 = document.get_page(0).unwrap();
    let page2 = document.get_page(0).unwrap();
    
    // Both should have the same dimensions (basic check that they represent the same page)
    assert_eq!(page1.width(), page2.width());
    assert_eq!(page1.height(), page2.height());
}