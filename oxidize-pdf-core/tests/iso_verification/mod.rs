//! ISO 32000-1:2008 Compliance Verification Tests
//!
//! This module provides a comprehensive test suite for verifying PDF compliance
//! with ISO 32000-1:2008 standard. Tests are organized by ISO sections and
//! verification levels.
//!
//! ## Verification Levels
//!
//! - **Level 0**: Not Implemented - Feature is not available
//! - **Level 1**: Code Exists - API exists and doesn't crash
//! - **Level 2**: Generates PDF - Creates valid PDF output
//! - **Level 3**: Content Verified - PDF content is structurally correct
//! - **Level 4**: ISO Compliant - Passes external validation tools

use oxidize_pdf::verification::{
    iso_matrix::{load_matrix, ComplianceSystem, IsoMatrix, VerificationStatus},
    parser::parse_pdf,
    validators::check_available_validators,
    verify_iso_requirement, IsoRequirement, VerificationLevel, VerificationResult,
};
use oxidize_pdf::{Document, Font, Page, Result as PdfResult};
use std::collections::HashMap;
use std::fs;
use std::process::Command;

pub mod section_7_syntax;
pub mod section_8_graphics;
pub mod section_9_text;

/// Helper for creating test PDFs with basic structure
pub fn create_basic_test_pdf(title: &str, content: &str) -> PdfResult<Vec<u8>> {
    let mut doc = Document::new();
    doc.set_title(title);
    doc.set_author("ISO Verification Test Suite");
    doc.set_creator("oxidize-pdf");

    let mut page = Page::a4();
    
    // Title
    page.text()
        .set_font(Font::Helvetica, 16.0)
        .at(50.0, 750.0)
        .write(title)?;
    
    // Content
    page.text()
        .set_font(Font::TimesRoman, 12.0)
        .at(50.0, 700.0)
        .write(content)?;

    // Ensure minimum content for level 2 verification
    page.text()
        .set_font(Font::Courier, 10.0)
        .at(50.0, 650.0)
        .write("This PDF is generated for ISO 32000-1:2008 compliance verification")?;

    doc.add_page(page);
    doc.to_bytes()
}

/// Helper for verifying PDF at different levels
pub fn verify_pdf_at_level(
    pdf_bytes: &[u8],
    requirement_id: &str,
    level: VerificationLevel,
    description: &str,
) -> VerificationResult {
    let requirement = IsoRequirement {
        id: requirement_id.to_string(),
        name: format!("Test Requirement {}", requirement_id),
        description: description.to_string(),
        iso_reference: format!("ISO Section {}", requirement_id),
        implementation: if level as u8 > 0 {
            Some("oxidize-pdf test".to_string())
        } else {
            None
        },
        test_file: Some("iso_verification tests".to_string()),
        level,
        verified: level as u8 >= 2,
        notes: "Generated by test suite".to_string(),
    };

    verify_iso_requirement(pdf_bytes, &requirement).unwrap_or_else(|e| VerificationResult {
        level,
        passed: false,
        details: format!("Verification error: {}", e),
        external_validation: None,
    })
}

/// Helper for updating verification status automatically
pub fn update_iso_status(
    requirement_id: &str,
    level: u8,
    test_location: &str,
    notes: &str,
) -> bool {
    // Call the Python script to update status
    let script_path = "../../../scripts/update_verification_status.py";
    let result = Command::new("python3")
        .arg(script_path)
        .arg("--req-id")
        .arg(requirement_id)
        .arg("--level")
        .arg(level.to_string())
        .arg("--test-file")
        .arg(test_location)
        .arg("--notes")
        .arg(notes)
        .output();

    match result {
        Ok(output) => {
            if output.status.success() {
                println!("âœ“ Updated ISO status for {}: level {}", requirement_id, level);
                true
            } else {
                eprintln!("âš ï¸  Failed to update ISO status for {}: {}", 
                    requirement_id, 
                    String::from_utf8_lossy(&output.stderr));
                false
            }
        }
        Err(e) => {
            eprintln!("âš ï¸  Could not run status update script: {}", e);
            false
        }
    }
}

/// Macro to create an ISO compliance test
macro_rules! iso_test {
    ($test_name:ident, $req_id:expr, $level:expr, $description:expr, $test_body:block) => {
        #[test]
        fn $test_name() -> PdfResult<()> {
            println!("ðŸ” Testing ISO requirement {} at level {:?}", $req_id, $level);
            
            let result = $test_body;
            
            let (passed, level_achieved, notes) = match result {
                Ok((success, actual_level, note)) => (success, actual_level, note),
                Err(e) => (false, 0, format!("Test error: {}", e)),
            };
            
            // Update ISO status
            let test_location = format!("{}::{}", module_path!(), stringify!($test_name));
            update_iso_status($req_id, level_achieved, &test_location, &notes);
            
            if passed {
                println!("âœ… ISO {} - Level {} achieved", $req_id, level_achieved);
            } else {
                println!("âŒ ISO {} - Test failed: {}", $req_id, notes);
            }
            
            assert!(passed, "ISO requirement {} failed: {}", $req_id, notes);
            Ok(())
        }
    };
}

pub(crate) use iso_test;

/// Helper to check if external validators are available
pub fn get_available_validators() -> Vec<String> {
    check_available_validators()
}

/// Helper to run external validation if tools are available
pub fn run_external_validation(pdf_bytes: &[u8], validator: &str) -> Option<bool> {
    if !get_available_validators().contains(&validator.to_string()) {
        return None;
    }

    match validator {
        "qpdf" => run_qpdf_validation(pdf_bytes),
        "verapdf" => run_verapdf_validation(pdf_bytes),
        _ => None,
    }
}

fn run_qpdf_validation(pdf_bytes: &[u8]) -> Option<bool> {
    // Write PDF to temporary file
    let temp_path = "/tmp/iso_test.pdf";
    if fs::write(temp_path, pdf_bytes).is_err() {
        return None;
    }

    // Run qpdf validation
    let output = Command::new("qpdf")
        .arg("--check")
        .arg(temp_path)
        .output()
        .ok()?;

    // Clean up
    let _ = fs::remove_file(temp_path);

    Some(output.status.success())
}

fn run_verapdf_validation(pdf_bytes: &[u8]) -> Option<bool> {
    // Write PDF to temporary file
    let temp_path = "/tmp/iso_test.pdf";
    if fs::write(temp_path, pdf_bytes).is_err() {
        return None;
    }

    // Run veraPDF validation
    let output = Command::new("verapdf")
        .arg("--format")
        .arg("text")
        .arg(temp_path)
        .output()
        .ok()?;

    // Clean up
    let _ = fs::remove_file(temp_path);

    Some(output.status.success() && 
         !String::from_utf8_lossy(&output.stdout).contains("FAIL"))
}

/// Generate a comprehensive test report
pub fn generate_test_report() -> PdfResult<String> {
    let mut report = String::new();
    
    report.push_str("# ISO 32000-1:2008 Compliance Test Report\n\n");
    report.push_str(&format!("Generated: {}\n\n", chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")));
    
    // Load current status if available
    if let Ok(status_content) = fs::read_to_string("ISO_VERIFICATION_STATUS.toml") {
        if let Ok(status_data) = toml::from_str::<HashMap<String, toml::Value>>(&status_content) {
            if let Some(stats) = status_data.get("statistics") {
                report.push_str("## Overall Statistics\n\n");
                if let Some(total) = stats.get("level_0_count").and_then(|v| v.as_integer()) {
                    report.push_str(&format!("- Level 0 (Not Implemented): {}\n", total));
                }
                if let Some(level1) = stats.get("level_1_count").and_then(|v| v.as_integer()) {
                    report.push_str(&format!("- Level 1 (Code Exists): {}\n", level1));
                }
                if let Some(level2) = stats.get("level_2_count").and_then(|v| v.as_integer()) {
                    report.push_str(&format!("- Level 2 (Generates PDF): {}\n", level2));
                }
                if let Some(level3) = stats.get("level_3_count").and_then(|v| v.as_integer()) {
                    report.push_str(&format!("- Level 3 (Content Verified): {}\n", level3));
                }
                if let Some(level4) = stats.get("level_4_count").and_then(|v| v.as_integer()) {
                    report.push_str(&format!("- Level 4 (ISO Compliant): {}\n", level4));
                }
                if let Some(avg) = stats.get("average_level").and_then(|v| v.as_float()) {
                    report.push_str(&format!("- Average Level: {:.2}\n", avg));
                }
                if let Some(pct) = stats.get("compliance_percentage").and_then(|v| v.as_float()) {
                    report.push_str(&format!("- Overall Compliance: {:.1}%\n\n", pct));
                }
            }
        }
    }
    
    report.push_str("## Available External Validators\n\n");
    let validators = get_available_validators();
    if validators.is_empty() {
        report.push_str("No external validators available for Level 4 verification.\n\n");
    } else {
        for validator in validators {
            report.push_str(&format!("- {}\n", validator));
        }
        report.push_str("\n");
    }
    
    report.push_str("## Test Coverage by Section\n\n");
    report.push_str("- Section 7 (Syntax): Document Structure, Objects, File Structure\n");
    report.push_str("- Section 8 (Graphics): Color Spaces, Images, Paths, Graphics State\n");
    report.push_str("- Section 9 (Text): Fonts, Text Operators, Character Encoding\n\n");
    
    report.push_str("---\n");
    report.push_str("Generated by oxidize-pdf ISO compliance test suite\n");
    
    Ok(report)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_pdf_creation() -> PdfResult<()> {
        let pdf_bytes = create_basic_test_pdf("Test PDF", "Test content")?;
        assert!(pdf_bytes.len() > 1000, "PDF should be at least 1KB");
        
        // Verify it can be parsed
        let parsed = parse_pdf(&pdf_bytes)?;
        assert!(parsed.version.starts_with("1."), "Should have valid PDF version");
        assert!(parsed.object_count > 0, "Should have objects");
        
        Ok(())
    }

    #[test]
    fn test_verification_helpers() {
        let pdf_bytes = create_basic_test_pdf("Helper Test", "Testing helpers").unwrap();
        
        let result = verify_pdf_at_level(
            &pdf_bytes,
            "test.helper",
            VerificationLevel::GeneratesPdf,
            "Testing helper functions"
        );
        
        assert!(result.passed, "Helper verification should pass");
        assert_eq!(result.level, VerificationLevel::GeneratesPdf);
    }

    #[test]
    fn test_report_generation() {
        let report = generate_test_report().unwrap();
        assert!(report.contains("# ISO 32000-1:2008 Compliance Test Report"));
        assert!(report.contains("Generated:"));
        assert!(report.len() > 500, "Report should be substantial");
    }
}