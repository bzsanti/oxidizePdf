//! Test program demonstrating Type0 font support for full Unicode
//!
//! NOTE: This example is currently broken due to Font type mismatches
//! and needs to be refactored

use oxidize_pdf::fonts::{create_type0_from_font, needs_type0_font};
use oxidize_pdf::text::font_manager::{CustomFont, FontManager};
use oxidize_pdf::{Color, Document, Font, Page, Result};

fn main() -> Result<()> {
    println!("Creating PDF with Type0 font for full Unicode support...");

    // TODO: Fix Font type mismatches in this example
    println!("Example currently broken - needs refactoring");
    return Ok(());

    #[allow(unreachable_code, unused_variables)]
    {
        let mut document = Document::new();
        document.set_title("Type0 Unicode Test");
        document.set_author("oxidize-pdf");

        let mut page = Page::new(612.0, 792.0);
        page.set_margins(50.0, 50.0, 50.0, 50.0);

        let graphics = page.graphics();
        graphics.set_fill_color(Color::black());

        // Test various Unicode texts
        let test_texts = vec![
            ("Basic ASCII:", "Hello World!"),
            ("Spanish:", "¡Hola! ¿Cómo estás? Añadir niño"),
            ("French:", "Français: élève, château, naïve"),
            ("German:", "Über, größer, Äpfel, öffnen"),
            ("Math Symbols:", "∑ ∏ ∫ √ ∞ ± × ÷ ≈ ≠ ≤ ≥"),
            ("Arrows:", "→ ← ↑ ↓ ↔ ⇒ ⇐ ⇑ ⇓ ⇔"),
            ("Checkboxes:", "☐ ☑ ☒ ✓ ✗ ✔ ✘"),
            ("Bullets:", "• ◦ ▪ ▫ ■ □ ▲ ▼"),
            ("Greek:", "α β γ δ ε ζ η θ ι κ λ μ"),
            ("Currency:", "€ £ ¥ $ ¢ ₹ ₽ ₨"),
            ("Fractions:", "½ ⅓ ¼ ⅛ ⅔ ¾ ⅝"),
            ("Superscript:", "x² y³ 2⁴ 10⁵"),
            ("Copyright:", "© ® ™ § ¶ † ‡"),
        ];

        // Load or create a font with Type0 support
        let mut font_manager = FontManager::new();

        // Try to load a system TrueType font
        let font_paths = vec![
            "/System/Library/Fonts/Helvetica.ttc",
            "/System/Library/Fonts/Supplemental/Arial Unicode.ttf",
            "/Library/Fonts/Arial Unicode.ttf",
            "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
            "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
        ];

        let mut font_loaded = false;
        let mut font_name = String::new();

        for path in font_paths {
            if std::path::Path::new(path).exists() {
                match CustomFont::load_truetype_font(path) {
                    Ok(custom_font) => {
                        // Convert to Type0 if needed for Unicode
                        let needs_type0 = test_texts.iter().any(|(_, text)| needs_type0_font(text));

                        if needs_type0 {
                            println!("Converting font to Type0 for full Unicode support...");
                            // Create a basic Font from CustomFont data
                            let mut base_font = Font::custom(custom_font.name.clone());
                            // TODO: Fix type mismatch
                            // base_font.data = custom_font.font_data.unwrap_or_default();
                            // base_font.metrics = oxidize_pdf::fonts::FontMetrics {
                                units_per_em: 1000,
                                ascent: custom_font.descriptor.ascent as i16,
                                descent: custom_font.descriptor.descent as i16,
                                line_gap: 200,
                                cap_height: custom_font.descriptor.cap_height as i16,
                                x_height: 500,
                            };

                            // Create Type0 font
                            let mut type0_font = create_type0_from_font(base_font);

                            // Mark all test characters as used
                            for (_, text) in &test_texts {
                                type0_font.mark_chars_used(text);
                            }

                            // Generate ToUnicode CMap
                            let to_unicode_cmap = type0_font.generate_to_unicode_cmap();
                            println!(
                                "Generated ToUnicode CMap with {} bytes",
                                to_unicode_cmap.len()
                            );

                            font_name = format!("Type0Font_{}", custom_font.name);

                            // Register as a custom font with Type0 properties
                            let mut type0_custom_font = custom_font;
                            type0_custom_font.name = font_name.clone();
                            type0_custom_font.font_type =
                                oxidize_pdf::text::font_manager::FontType::Type0;
                            type0_custom_font.encoding =
                                oxidize_pdf::text::font_manager::FontEncoding::Identity;

                            font_manager.register_font(type0_custom_font)?;
                        } else {
                            font_name = font_manager.register_font(custom_font)?;
                        }

                        font_loaded = true;
                        println!("Loaded font from: {}", path);
                        break;
                    }
                    Err(e) => {
                        println!("Failed to load {}: {}", path, e);
                        continue;
                    }
                }
            }
        }

        if !font_loaded {
            // Create a fallback Type0 font
            println!("Creating fallback Type0 font...");
            let base_font = Font::custom("FallbackFont");
            let mut type0_font = create_type0_from_font(base_font);

            // Mark all test characters as used
            for (_, text) in &test_texts {
                type0_font.mark_chars_used(text);
            }

            type0_font.generate_to_unicode_cmap();
            font_name = "Type0Fallback".to_string();
        }

        // Render test texts
        let mut y = 700.0;

        for (label, text) in test_texts {
            // Draw label
            graphics.save_state();
            graphics.begin_text();
            graphics.set_font(Font::Helvetica, 12.0);
            graphics.set_text_position(60.0, y);
            graphics.show_text(label)?;
            graphics.end_text();
            graphics.restore_state();

            // Draw Unicode text with Type0 font
            graphics.save_state();
            graphics.begin_text();

            if font_loaded {
                // Use custom Type0 font
                graphics.set_custom_font(&font_name, 14.0);

                // For Type0 fonts, we need to encode as hex string
                let mut hex_text = String::from("<");
                for ch in text.chars() {
                    // Simple encoding for demonstration
                    // In production, use proper CID encoding
                    let code = ch as u32;
                    if code <= 0xFFFF {
                        hex_text.push_str(&format!("{:04X}", code));
                    } else {
                        // Use replacement character for non-BMP
                        hex_text.push_str("FFFD");
                    }
                }
                hex_text.push('>');

                graphics.set_text_position(200.0, y);
                graphics.show_text(&hex_text)?;
            } else {
                // Fallback to standard font (won't show all characters)
                graphics.set_font(Font::Helvetica, 14.0);
                graphics.set_text_position(200.0, y);
                graphics.show_text(text)?;
            }

            graphics.end_text();
            graphics.restore_state();

            y -= 25.0;
        }

        // Add note about Type0 fonts
        graphics.save_state();
        graphics.begin_text();
        graphics.set_font(Font::Helvetica, 10.0);
        graphics.set_fill_color(Color::gray(0.5));
        graphics.set_text_position(60.0, 100.0);
        graphics
            .show_text("Note: This PDF uses Type0 (Composite) fonts for full Unicode support.")?;
        graphics.set_text_position(60.0, 85.0);
        graphics.show_text(
            "Characters are encoded using CIDs (Character IDs) for large character sets.",
        )?;
        graphics.end_text();
        graphics.restore_state();

        document.add_page(page);

        // Save the PDF
        document.save("type0_unicode_test.pdf")?;

        println!("PDF saved as type0_unicode_test.pdf");
        println!("This PDF demonstrates Type0 font support for full Unicode including:");
        println!("- Mathematical symbols");
        println!("- Arrows and special symbols");
        println!("- Checkboxes and bullets");
        println!("- Greek letters");
        println!("- Currency symbols");
        println!("- And more!");

        Ok(())
    }
}
