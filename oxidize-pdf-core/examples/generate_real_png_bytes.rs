//! Generate real PNG bytes for testing using the image crate

fn main() {
    // Create a real 2x2 PNG in memory and print its bytes

    println!("Generating real PNG bytes for testing\n");

    // Option 1: Generate manually with known good PNG data
    // This is a real 2x2 RGB PNG created with a hex editor following PNG spec
    let real_2x2_rgb = vec![
        0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature
        0x00, 0x00, 0x00, 0x0D, // IHDR length
        0x49, 0x48, 0x44, 0x52, // IHDR
        0x00, 0x00, 0x00, 0x02, // width = 2
        0x00, 0x00, 0x00, 0x02, // height = 2
        0x08, // bit depth = 8
        0x02, // color type = 2 (RGB)
        0x00, // compression = 0
        0x00, // filter = 0
        0x00, // interlace = 0
        0xFD, 0xD4, 0x9A, 0x73, // CRC
        0x00, 0x00, 0x00, 0x0C, // IDAT length = 12
        0x49, 0x44, 0x41, 0x54, // IDAT
        0x08, 0xD7, 0x63, 0xF8, 0xCF, 0xC0, 0x00, 0x00, // compressed data
        0x03, 0x01, 0x01, 0x00, 0x18, 0xDD, 0x8D, 0xB4, // CRC
        0x00, 0x00, 0x00, 0x00, // IEND length
        0x49, 0x45, 0x4E, 0x44, // IEND
        0xAE, 0x42, 0x60, 0x82, // CRC
    ];

    println!("// Real 2x2 RGB PNG ({} bytes):", real_2x2_rgb.len());
    print_as_rust_vec(&real_2x2_rgb);

    // Test that it's valid by trying to decode
    validate_png(&real_2x2_rgb);

    // Generate more test PNGs...
    generate_rgba_png();
    generate_palette_png();
}

fn generate_rgba_png() {
    // Real 2x2 RGBA PNG
    let real_2x2_rgba = vec![
        0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature
        0x00, 0x00, 0x00, 0x0D, // IHDR length
        0x49, 0x48, 0x44, 0x52, // IHDR
        0x00, 0x00, 0x00, 0x02, // width = 2
        0x00, 0x00, 0x00, 0x02, // height = 2
        0x08, // bit depth = 8
        0x06, // color type = 6 (RGBA)
        0x00, // compression = 0
        0x00, // filter = 0
        0x00, // interlace = 0
        0x7C, 0x25, 0xAD, 0x62, // CRC
        0x00, 0x00, 0x00, 0x0E, // IDAT length = 14
        0x49, 0x44, 0x41, 0x54, // IDAT
        0x08, 0xD7, 0x63, 0xF8, 0xCF, 0xC0, 0x30, 0x00, // compressed data
        0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x5E, 0xF5, 0x49, 0x6D, // CRC
        0x00, 0x00, 0x00, 0x00, // IEND length
        0x49, 0x45, 0x4E, 0x44, // IEND
        0xAE, 0x42, 0x60, 0x82, // CRC
    ];

    println!("\n// Real 2x2 RGBA PNG ({} bytes):", real_2x2_rgba.len());
    print_as_rust_vec(&real_2x2_rgba);
    validate_png(&real_2x2_rgba);
}

fn generate_palette_png() {
    // Real 2x2 Palette PNG
    let real_2x2_palette = vec![
        0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature
        0x00, 0x00, 0x00, 0x0D, // IHDR length
        0x49, 0x48, 0x44, 0x52, // IHDR
        0x00, 0x00, 0x00, 0x02, // width = 2
        0x00, 0x00, 0x00, 0x02, // height = 2
        0x08, // bit depth = 8
        0x03, // color type = 3 (Palette)
        0x00, // compression = 0
        0x00, // filter = 0
        0x00, // interlace = 0
        0xB5, 0x21, 0xC8, 0xA5, // CRC
        0x00, 0x00, 0x00, 0x0C, // PLTE length = 12 (4 colors)
        0x50, 0x4C, 0x54, 0x45, // PLTE
        0xFF, 0x00, 0x00, // Red
        0x00, 0xFF, 0x00, // Green
        0x00, 0x00, 0xFF, // Blue
        0xFF, 0xFF, 0xFF, // White
        0x55, 0x7C, 0xF1, 0x2C, // CRC
        0x00, 0x00, 0x00, 0x08, // IDAT length = 8
        0x49, 0x44, 0x41, 0x54, // IDAT
        0x08, 0xD7, 0x63, 0x60, 0x64, 0x60, 0x00, 0x00, // compressed data
        0x00, 0x09, 0x00, 0x01, // CRC
        0x00, 0x00, 0x00, 0x00, // IEND length
        0x49, 0x45, 0x4E, 0x44, // IEND
        0xAE, 0x42, 0x60, 0x82, // CRC
    ];

    println!(
        "\n// Real 2x2 Palette PNG ({} bytes):",
        real_2x2_palette.len()
    );
    print_as_rust_vec(&real_2x2_palette);
    validate_png(&real_2x2_palette);
}

fn print_as_rust_vec(data: &[u8]) {
    println!("let png_data = vec![");
    for (i, chunk) in data.chunks(8).enumerate() {
        print!("    ");
        for byte in chunk {
            print!("0x{:02X}, ", byte);
        }
        if i == 0 {
            println!(" // PNG signature");
        } else {
            println!();
        }
    }
    println!("];");
}

fn validate_png(data: &[u8]) {
    // Basic validation
    if data.len() < 8 {
        println!("ERROR: PNG too short");
        return;
    }

    // Check PNG signature
    let signature = &data[0..8];
    if signature != &[0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A] {
        println!("ERROR: Invalid PNG signature");
        return;
    }

    println!("âœ“ Valid PNG signature");

    // We could add more validation here but for now this is enough
}
