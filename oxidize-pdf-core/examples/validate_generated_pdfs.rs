//! PDF Generation Validation Suite
//!
//! This example validates that the PDFs generated by our comprehensive tests
//! can be successfully parsed by our own PDF parser, ensuring complete
//! round-trip functionality.

use oxidize_pdf::parser::{ParseOptions, PdfReader};
use std::time::Instant;

/// Validate a specific PDF file by parsing it and extracting basic information
fn validate_pdf_file(file_path: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("📄 Validating: {}", file_path);
    let start = Instant::now();

    // Try to open and parse the PDF
    let file = std::fs::File::open(file_path)?;
    let mut reader = PdfReader::new_with_options(file, ParseOptions::lenient())?;

    // Get basic document information
    let version = reader.version().to_string();
    let page_count = reader.page_count()?;

    println!("   📋 PDF Version: {}", version);
    println!("   📄 Page Count: {}", page_count);

    // Try to parse the document structure
    let document = reader.into_document();

    // Try to extract text from all pages
    let mut total_chars = 0;
    let mut pages_with_text = 0;

    for page_idx in 0..page_count {
        match document.extract_text_from_page(page_idx) {
            Ok(text_result) => {
                let char_count = text_result.text.chars().count();
                if char_count > 0 {
                    pages_with_text += 1;
                    total_chars += char_count;
                }
            }
            Err(e) => {
                println!(
                    "   ⚠️  Warning: Could not extract text from page {}: {}",
                    page_idx, e
                );
            }
        }
    }

    println!("   📝 Pages with text: {}/{}", pages_with_text, page_count);
    println!("   🔢 Total characters extracted: {}", total_chars);

    let duration = start.elapsed();
    println!("   ✅ Validation completed in {:?}", duration);
    println!();

    Ok(())
}

/// Run comprehensive validation of all generated PDFs
fn validate_all_generated_pdfs() -> Result<(), Box<dyn std::error::Error>> {
    println!("🔍 PDF Generation Validation Suite - v1.1.0");
    println!("Validating PDFs generated by comprehensive test suite...\n");

    let test_files = [
        "test_output/basic_pdf_test.pdf",
        "test_output/multi_page_test.pdf",
        "test_output/advanced_graphics_test.pdf",
        "test_output/business_report_test.pdf",
    ];

    let total_start = Instant::now();
    let mut successful_validations = 0;
    let mut failed_validations = 0;

    for file_path in &test_files {
        match validate_pdf_file(file_path) {
            Ok(()) => {
                successful_validations += 1;
            }
            Err(e) => {
                println!("❌ VALIDATION FAILED for {}: {}", file_path, e);
                failed_validations += 1;
            }
        }
    }

    let total_duration = total_start.elapsed();

    println!("🎯 VALIDATION SUMMARY");
    println!("=====================================");
    println!(
        "✅ Successful validations: {}/{}",
        successful_validations,
        test_files.len()
    );
    println!("❌ Failed validations: {}", failed_validations);
    println!("⏱️  Total validation time: {:?}", total_duration);

    if failed_validations == 0 {
        println!("\n🎉 ALL PDFs VALIDATED SUCCESSFULLY!");
        println!("✅ PDF generation → parsing round-trip is 100% functional");
        println!("✅ oxidize-pdf v1.1.0 generation and parsing are fully compatible");
        println!("✅ Ready for production use");
    } else {
        println!("\n⚠️  Some validations failed. Please review the errors above.");
        return Err("PDF validation failures detected".into());
    }

    Ok(())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    validate_all_generated_pdfs()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generated_pdf_validation() {
        validate_all_generated_pdfs().expect("All generated PDFs should validate successfully");
    }
}
