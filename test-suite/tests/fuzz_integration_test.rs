//! Integration tests for fuzzing infrastructure
//!
//! These tests verify that the fuzzing setup is working correctly.

#[test]
#[ignore = "requires cargo-fuzz to be installed"]
fn test_fuzz_targets_exist() {
    use std::path::Path;

    let fuzz_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("fuzz");
    assert!(fuzz_dir.exists(), "Fuzz directory should exist");

    // Check that fuzz targets exist
    let targets_dir = fuzz_dir.join("fuzz_targets");
    assert!(targets_dir.exists(), "Fuzz targets directory should exist");

    // Check individual targets
    let expected_targets = [
        "fuzz_parser.rs",
        "fuzz_content_parser.rs",
        "fuzz_operations.rs",
        "fuzz_generator.rs",
    ];

    for target in &expected_targets {
        let target_path = targets_dir.join(target);
        assert!(target_path.exists(), "Fuzz target {target} should exist");
    }
}

#[test]
fn test_fuzz_corpus_seeds() {
    use oxidize_pdf_test_suite::generators::test_pdf_builder::TestPdfBuilder;

    // Generate seed PDFs for fuzzing
    let seeds = vec![
        ("minimal", TestPdfBuilder::minimal().build()),
        ("empty_page", {
            let mut builder = TestPdfBuilder::new();
            builder.add_empty_page(612.0, 792.0);
            builder.build()
        }),
        ("text_page", {
            let mut builder = TestPdfBuilder::new();
            builder.add_text_page("Fuzzing seed text", 12.0);
            builder.build()
        }),
        ("graphics_page", {
            let mut builder = TestPdfBuilder::new();
            builder.add_graphics_page();
            builder.build()
        }),
    ];

    // Verify seeds are valid PDFs
    for (name, pdf) in seeds {
        assert!(
            pdf.starts_with(b"%PDF-"),
            "{name} should start with PDF header"
        );
        assert!(pdf.len() > 100, "{name} should have reasonable size");
    }
}

// TODO: Re-enable when parse_page_range is made public
/*
#[test]
fn test_page_range_fuzzing_inputs() {
    use oxidize_pdf::operations::parse_page_range;

    // Test cases that might be generated by fuzzer
    let test_cases = vec![
        "1",
        "1-5",
        "1,3,5",
        "1-3,5-7",
        "even",
        "odd",
        "all",
        "1-",                   // Should handle gracefully
        "-5",                   // Should handle gracefully
        "abc",                  // Should handle gracefully
        "",                     // Should handle gracefully
        "1,2,3,4,5,6,7,8,9,10", // Long list
        "1-1000000",            // Large range
    ];

    for case in test_cases {
        // Should not panic
        let _ = parse_page_range(case);
    }
}
*/

#[test]
fn test_content_parser_fuzzing_inputs() {
    use oxidize_pdf::parser::content::ContentParser;

    // Edge cases for content parser
    let test_cases: Vec<&[u8]> = vec![
        b"",                      // Empty
        b"BT",                    // Incomplete text object
        b"BT ET",                 // Empty text object
        b"q Q",                   // Empty graphics state
        b"1 0 0 1 0 0 cm",        // Transform matrix
        b"(Hello\\)World)",       // Escaped parenthesis
        b"<48656c6c6f>",          // Hex string
        b"[1 2 3] TJ",            // Array show text
        b"q q q q Q Q Q Q",       // Nested graphics states
        b"BT BT ET ET",           // Nested text objects (invalid)
        b"100 200 m 300 400 l S", // Path construction
        b"1 w 2 J 3 j",           // Line properties
        b"0.5 g 0.5 G",           // Gray color
        b"/Name",                 // Name object
        b"123.456",               // Number
        b"  \n\r\t  ",            // Whitespace only
        &[0xFF, 0xFE, 0xFD],      // Binary data
        b"% Comment line\nBT ET", // Comments
    ];

    for case in test_cases {
        // Should not panic
        let _ = ContentParser::parse(case);
    }
}

#[test]
#[ignore = "requires nightly rust and cargo-fuzz"]
fn test_run_minimal_fuzz() {
    use std::path::Path;
    use std::process::Command;

    let fuzz_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("fuzz");

    // Check if cargo-fuzz is available
    let check = Command::new("cargo").args(["fuzz", "--version"]).output();

    if check.is_err() || !check.unwrap().status.success() {
        eprintln!("cargo-fuzz not installed, skipping test");
        return;
    }

    // Run fuzzer for a very short time just to verify it works
    let output = Command::new("cargo")
        .args(["fuzz", "run", "fuzz_parser", "--", "-runs=1"])
        .current_dir(&fuzz_dir)
        .output()
        .expect("Failed to run fuzzer");

    if !output.status.success() {
        eprintln!("Fuzzer stderr: {}", String::from_utf8_lossy(&output.stderr));
    }

    assert!(output.status.success(), "Fuzzer should run successfully");
}
